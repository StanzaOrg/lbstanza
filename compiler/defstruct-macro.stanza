#use-added-syntax(dot-operator)
defpackage stz/defstruct-macro :
  import core
  import collections
  import macro-utils
  import stz/core-macros

;============================================================
;=================== Parsed Representation ==================
;============================================================

;Represents a Stanza 'defstruct' form.
;- name: The name of the struct itself.
;- targs: The type arguments of the struct.
;- parent: The core form representing the parent type, if provided.
;- fields: The fields in the structure.
;- constructor: Determines the name/status of the positional constructor.
;  - Symbol: Use this as the name of generated constructor.
;  - True: Use the default name (same name as the struct).
;  - False: Do not generate the positional constructor.
;- keyword-constructor: Determines the name/status of the keyword constructor.
;  - Symbol: Use this as the name of generated constructor.
;  - True: Use the default name (same name as the struct).
;  - False: Do not generate the positional constructor.
;- printer?: True if a default printer should be autogenerated.
;- writer?: True if a default writer should be autogenerated.
;- equalable?: True if a default equal? method should be autogenerated.
;- hashable?: True if a default hash method should be autogenerated.
;- meta-utils?: True if meta-programming bindings should be autogenerated.
public defstruct DefStructForm :
  name:Token|Symbol
  targs:List<Token|Symbol>
  parent:Maybe
  fields:List<StructField>
  constructor:Token|True|False|Symbol
  keyword-constructor:Token|True|False|Symbol
  printer?: True|False|ForwardToWriter
  writer?: True|False
  equalable?: True|False
  hashable?: True|False
  meta-utils?: True|False

;Represents a field declaration in a DefStruct.
;- name: The name of the field.
;- type: The core form representing the type of the field.
;- doc-string: The $doc form containing the documentation string for
;  the field, if given.
;- as-method?: True if the field functions should be defined as
;  methods instead of functions.
;- setter: Determines the name/status of the generated setter.
;  - Symbol: Use this as the name of generated setter.
;  - True: Use the default name (set-xxx).
;  - False: No setter.
;- updater: Determines the name/status of the generated updater.
;- ensure: The core form containing the invariant the field should
;  satisfy, if provided.
;- init: The core form containing the initial value of the field,
;  if provided. Supports the special 'void' value.
;- default: The core form containing the default value of the field,
;  if provided. Supports the special 'void' value.
public defstruct StructField :
  name:Token|Symbol
  type:?
  doc-string:Maybe
  as-method?:True|False
  setter:Token|True|False|Symbol
  updater:Token|True|False|Symbol
  ensure:Maybe
  init:Maybe
  default:Maybe with: (updater => sub-default)

;Flag to indicate for the generated printer
;to forward to writer.
public defstruct ForwardToWriter

;============================================================
;====================== Options =============================
;============================================================

;Listing of all supported struct options.
public deftype StructOption
public defstruct Constructor <: StructOption: (value:Token|True|False|Symbol)
public defstruct KeywordConstructor <: StructOption: (value:Token|True|False|Symbol)
public defstruct GenPrinter <: StructOption: (value:True|False)
public defstruct GenWriter <: StructOption: (value:True|False)
public defstruct GenEqual <: StructOption: (value:True|False)
public defstruct GenHash <: StructOption: (value:True|False)
public defstruct GenMetaUtils <: StructOption: (value:True|False)

;Listing of all supported field options.
public deftype FieldOption
public defstruct AsMethod <: FieldOption: (value:True|False)
public defstruct Setter <: FieldOption: (value:Token|True|False|Symbol)
public defstruct Updater <: FieldOption: (value:Token|True|False|Symbol)
public defstruct Ensure <: FieldOption: (exp)
public defstruct Init <: FieldOption: (exp)
public defstruct Default <: FieldOption: (exp)

;Retrieve the name of the field option.
defn name (o:FieldOption) -> Symbol :
  match(o) :
    (o:AsMethod) : `as-method
    (o:Setter) : `setter
    (o:Updater) : `updater
    (o:Ensure) : `ensure
    (o:Init) : `init
    (o:Default) : `default

;Retrieve the name of the struct option.
defn name (o:StructOption) -> Symbol :
  match(o) :
    (o:Constructor) : `constructor
    (o:KeywordConstructor) : `keyword-constructor
    (o:GenPrinter) : `printer
    (o:GenWriter) : `writer
    (o:GenEqual) : `equal
    (o:GenHash) : `hash
    (o:GenMetaUtils) : `meta-utils

;Create a StructField from the given options.
public defn StructField (info:FileInfo|False,
                         name:Token|Symbol,
                         type,
                         doc-string:Maybe,
                         options:Tuple<FieldOption>) -> StructField :

  ;Ensure that no duplicate options are provided.
  ensure-no-duplicate-options!(info, seq(/name,options))

  ;Process the options.
  var as-method = false
  var setter = false
  var updater = false
  var ensure = None()
  var init = None()
  var default = None()
  for o in options :
    match(o) :
      (o:AsMethod) : as-method = o.value
      (o:Setter) : setter = o.value
      (o:Updater) : updater = o.value
      (o:Ensure) : ensure = One(o.exp)
      (o:Init) : init = One(o.exp)
      (o:Default) : default = One(o.exp)

  ;Ensure that the 'init' and 'default' options are not used together.
  if init is One and default is One :
    val msg = "Field '%~' cannot have both an initialization and a \
               default value." % [name]
    throw(CSE(info, msg))

  ;Ensure that if field has initial value of 'void', that it has some
  ;way to alter it.
  if init.void? and setter.false? and updater.false? :
    val msg = "Field '%~' is uninitialized and has no setter or \
               updater." % [name]
    throw(CSE(info, msg))

  ;Create final struct.
  StructField(name,
              type,
              doc-string,
              as-method,
              setter,
              updater,
              ensure,
              init,
              default)

;Create a DefStructForm from the given options.
public defn DefStructForm (info:FileInfo|False,
                           name:Token|Symbol,
                           targs:List<Token|Symbol>,
                           parent:Maybe,
                           fields:List<StructField>,
                           options:Tuple<StructOption>) -> DefStructForm :

  ;Ensure that no duplicate options are provided.
  ensure-no-duplicate-options!(info, seq(/name,options))

  ;Process the options.
  var constructor = true
  var keyword-constructor = false
  var printer? = None()
  var writer? = false
  var equalable? = false
  var hashable? = false
  var meta-utils? = false
  for o in options :
    match(o) :
      (o:Constructor) : constructor = o.value
      (o:KeywordConstructor) : keyword-constructor = o.value
      (o:GenPrinter) : printer? = One(o.value)
      (o:GenWriter) : writer? = o.value
      (o:GenEqual) : equalable? = o.value
      (o:GenHash) : hashable? = o.value
      (o:GenMetaUtils) : meta-utils? = o.value

  ;Set printer to forward to writer unless explicitly
  ;given.
  if writer? and printer? is None :
    printer? = One(ForwardToWriter())

  ;Ensure that there is some constructor.
  if constructor.false? and keyword-constructor.false? :
    val msg = "Defstruct '%~' requires either a standard constructor \
               or a keyword constructor." % [name]
    throw(CSE(info, msg))

  ;If a keyword constructor is requested, ensure
  ;that the struct has at least one argument.
  if not keyword-constructor.false? :
    val has-named-arg? = for f in fields any? : f.init.empty?
    if not has-named-arg? :
      val msg = "Keyword constructor requested for defstruct '%~', but \
                 no fields are passed to the constructor as \
                 arguments." % [name]
      throw(CSE(info, msg))

  ;Create the DefStructForm.
  DefStructForm(name,
                targs,
                parent,
                fields,
                constructor,
                keyword-constructor,
                printer?.value?,
                writer?,
                equalable?,
                hashable?,
                meta-utils?)

;============================================================
;====================== Parsing =============================
;============================================================

defsyntax defstruct-syntax :
  import (exp!, doc-string?, id!, id, type!) from core

  ;Overall defstruct form.
  public defproduction defstruct-form: DefStructForm
  defrule defstruct-form = (defstruct ?name:#id! ?targs:#struct-targs ?parent:#struct-parent
                            ?fields:#struct-fields
                            ?options:#struct-options) :
    DefStructForm(closest-info(), name, targs, parent, fields, options)

  ;List of type arguments.
  defproduction struct-targs:List
  defrule struct-targs = ((@of ?xs:#id! ...))
  defrule struct-targs = () : List()

  ;List of struct fields.
  defproduction struct-fields:List<StructField>
  defrule struct-fields = (: (?fs:#struct-field! ...))
  defrule struct-fields = () : List()

  ;Optional struct parent.
  defproduction struct-parent:Maybe
  defrule struct-parent = (<: ?p:#type!) : One(p)
  defrule struct-parent = () : None()

  ;Set of struct options.
  defproduction struct-options:Tuple<StructOption>
  defrule struct-options = (with: (?options:#struct-option! ...)) : options.to-tuple
  defrule struct-options = () : []

  ;Syntax of each option.
  defproduction struct-option!:StructOption
  defrule struct-option! = (constructor ?name:#bool-id-setting) : Constructor(name)
  defrule struct-option! = (keyword-constructor ?name:#bool-id-setting) : KeywordConstructor(name)
  defrule struct-option! = (printer ?v:#bool-setting) : GenPrinter(v)
  defrule struct-option! = (writer ?v:#bool-setting) : GenWriter(v)
  defrule struct-option! = (equalable ?v:#bool-setting) : GenEqual(v)
  defrule struct-option! = (hashable ?v:#bool-setting) : GenHash(v)
  defrule struct-option! = (meta-utils ?v:#bool-setting) : GenMetaUtils(v)
  fail-if struct-option! = (?name:#id =>) : CSE(closest-info(), "Unsupported defstruct option '%~'." % [name])
  fail-if struct-option! = () : CSE(closest-info(), "Illegal syntax for struct option.")

  ;Individual defstruct field.
  defproduction struct-field!:StructField
  defrule struct-field! = (?doc-string:#doc-string?
                           ?name:#id! ?type:#field-type ?options:#field-options) :
    StructField(closest-info(), name, type, doc-string, options)
  fail-if struct-field! = () : CSE(closest-info(), "Expected a field declaration here.")

  ;Type of a struct field.
  defproduction field-type
  defrule field-type = (: ?t:#type!)
  defrule field-type = () : `?

  ;Set of field options.
  defproduction field-options:Tuple<FieldOption>
  defrule field-options = (with: (?options:#field-option! ...)) : options.to-tuple
  defrule field-options = () : []

  ;Individual field option.
  defproduction field-option!:FieldOption
  defrule field-option! = (as-method ?v:#bool-setting) : AsMethod(v)
  defrule field-option! = (setter ?v:#bool-id-setting) : Setter(v)
  defrule field-option! = (updater ?v:#bool-id-setting) : Updater(v)
  defrule field-option! = (ensure => ?v:#exp!) : Ensure(v)
  defrule field-option! = (init => ?v:#exp!) : Init(v)
  defrule field-option! = (default => ?v:#exp!) : Default(v)
  fail-if field-option! = (?name:#id =>) : CSE(closest-info(), "Unsupported field option '%~'." % [name])
  fail-if field-option! = () : CSE(closest-info(), "Illegal syntax for field option.")

  ;Arrow to bool
  defproduction bool-setting : True|False
  defrule bool-setting = (=> ?v:true) : true
  defrule bool-setting = (=> ?v:false) : false
  fail-if bool-setting = (=>) : CSE(closest-info(), "Expected a true/false value here.")
  defrule bool-setting = () : true

  ;Arrow to bool-or-id.
  defproduction bool-id-setting : Token|True|False|Symbol
  defrule bool-id-setting = (=> ?v:true)
  defrule bool-id-setting = (=> ?v:false)
  defrule bool-id-setting = (=> ?v:#id)
  fail-if bool-id-setting = (=>) : CSE(closest-info(), "Expected a true/false or symbol here.")
  defrule bool-id-setting = () : true

;Shorthand for CoreSyntaxError
defn CSE (info:FileInfo|False, msg) :
  CoreSyntaxError(info,msg)

;============================================================
;================= StructField Bindings =====================
;============================================================

;Generate the bindings for the given fields.
defn bindings (fields:List<StructField>,
               struct-name:Symbol|Token) -> Nested :

  ;Generate the bindings for the given field at index 'index'.
  defn bindings (field:StructField, index:Int) -> Tuple<KeyValue> :

    ;Compute the local name for the field. If the field has a setter,
    ;then the local name is the name of the 'var' variable, otherwise
    ;it is the same as the name.
    val local-name = if field.setter.false? : field.name
                     else : gensym(field.name)

    ;Compute the name to use as the argument. This is used so that
    ;we can reserve the actual name for within the body of the
    ;constructor.
    val arg-name = gensym(field.name)

    ;Compute whether the field is voidable. It is voidable if it
    ;has either 'init => void' or 'default => void' options.
    val voidable? = field.init.void? or field.default.void?

    ;Compute the local type of the field. If the field is voidable,
    ;then its type is Type|Uninitialized, otherwise it's just its
    ;declared type.
    val local-type =
      if voidable? :
        val field-type = field.type
        splice $ qquote(~ field-type | core/Uninitialized)
      else :
        field.type

    ;Compute whether a value is initialized by the initialization
    ;block of the positional constructor. There are three settings.
    val always-initialized = 0
    val never-initialized = 1
    val selectively-initialized = 2
    val initialized? =
      if not field.init.empty? :
        if voidable? : choice(never-initialized)
        else : choice(always-initialized)
      else if not field.default.empty? :
        if voidable? : choice(selectively-initialized)
        else : choice(always-initialized)
      else : choice(always-initialized)

    ;Compute setter name.
    val setter-name = match(field.setter.unwrap-token) :
      (name:Symbol) : field.setter
      (name:True) : sub-token-item?(field.setter, symbol-join(["set-", field.name]))
      (name:False) : false

    ;Compute updater name.
    val updater-name = match(field.updater.unwrap-token) :
      (name:Symbol) : field.updater
      (name:True) : sub-token-item?(field.updater, symbol-join(["sub-", field.name]))
      (name:False) : false

    [`name => field.name
     `type => field.type
     `first? => choice(index == 0)
     `doc-string => field.doc-string.value?
     `doc-string? => choice(not field.doc-string.empty?)
     `description => to-string("field %_/%_" % [struct-name, field.name])
     `qualified-name => symbol-join([struct-name '/' field.name])
     `method? => choice(field.as-method?)
     `setter? => choice(not field.setter.false?)
     `setter => setter-name
     `updater? => choice(not field.updater.false?)
     `updater => updater-name
     `ensure? => choice(not field.ensure.empty?)
     `ensure => field.ensure.value?
     `local-name => local-name
     `local-type => local-type
     `arg-name => arg-name
     `voidable? => choice(voidable?)
     `init? => choice(not field.init.empty?)
     `init-value => field.init.value?
     `default? => choice(not field.default.empty?)
     `default-value => field.default.value?
     `initialized? => initialized?]

  ;Generate the bindings for each field.
  nested $ to-tuple $
    for (field in fields, i in 0 to false) seq :
      bindings(field, i)

;============================================================
;================= Metaprogramming Utilities ================
;============================================================

;Generated methods for binding to meta-utilities.
defn meta-utils-methods (form:DefStructForm) -> ? :
  val template = `(
    meta-utils?{
      defmethod core/meta-utils/field-values (x:Struct) :
        [fields{name(x)}]
      defmethod core/meta-utils/field-names (x:Struct) :
        [fields{`name}]
      defmethod core/meta-utils/field-accessors (x:Struct) :
        val accessors = [fields{name upcast-as (Struct -> ?)}]
        accessors as Tuple<(core/meta-utils/HasMetaUtils -> ?)>
      defmethod core/meta-utils/field-entries (x:Struct) :
        [fields{`name => name(x)}]
    }{}
  )
  splice $ substitute(template, [
    `meta-utils? => choice(form.meta-utils?)])

;============================================================
;================= Hashable and Equalable ===================
;============================================================

;Generated methods for hashable and equalable.
defn hashable-equalable-methods (form:DefStructForm) -> ? :
  val template = `(
    equalable?{
      defmethod equal? (lhs:Struct, rhs:Struct) :
        has-fields?{
          fields{first?{}{and} equal?(name(lhs), name(rhs))}
        }{
          true
        }
    }{}

    hashable?{
      defmethod hash (x:Struct) :
        hash([Struct-name fields{name(x)}])
    }{}
  )

  splice $ substitute(template, [
    `equalable? => choice(form.equalable?)
    `hashable? => choice(form.hashable?)
    `equal? => `core/equal?
    `hash => `core/hash
    `lhs => gensym(`lhs)
    `rhs => gensym(`rhs)])

;============================================================
;=============== Field Multi Declarations ===================
;============================================================

;Generated deftype and multi declarations for struct fields.
defn deftype-and-multis (form:DefStructForm) -> ? :
  val template = `(

    ;Type declaration
    deftype Struct<targs{name}> meta-utils?{
                                  <: parent?{Parent &}{} core/meta-utils/HasMetaUtils
                                }{
                                  parent?{<: Parent}{}
                                }

    ;Field multis
    fields{
      method?{}{
        doc-string?{doc-string}{}
        defmulti name<targs{?name}> (x:Struct<targs{?name}>) -> type
        setter?{
          defmulti setter<targs{?name}> (x:Struct<targs{?name}>, v:type) -> False
        }{}
        updater?{
          defmulti updater<targs{?name}> (x:Struct<targs{?name}>, v:type) -> Struct<targs{name}>
        }{}
      }
    }
  )

  splice $ substitute(template, [
    `meta-utils? => choice(form.meta-utils?)
    `parent? => choice(not form.parent.empty?)
    `Parent => form.parent.value?])

;============================================================
;=============== Getters / Setters / Updaters ===============
;============================================================

;Generated instance methods for field getters, setters, and updaters.
;- main-constructor: The name of the "main constructor" used to
;  directly create an object.
defn getters-setters-updaters (main-constructor:Token|Symbol) -> ? :
  val template = `(

    ;Getters, setters, and updaters for each field.
    fields{

      ;Field getter.
      ;If voidable, then checks that the value is set.
      defmethod name (this) :
        voidable?{
          #if-not-defined(OPTIMIZE) :
            if local-name is Uninitialized :
              fatal("Field %_ has not been initialized." % [`qualified-name])
          local-name as type
        }{
          local-name
        }


      ;Field setter.
      ;Ensure that value satisfies preconditions.
      setter?{
        defmethod setter (this, value:type) :
          ensure?{
            #if-not-defined(OPTIMIZE) :
              ensure(description, value)
          }{}
          local-name = value
      }{}

      ;Field updater.
      ;Ensure that value satisfies preconditions.
      updater?{
        defmethod updater (this, local-name:type) :
          ensure?{
            #if-not-defined(OPTIMIZE) :
              ensure(description, local-name)
          }{}
          MainConstructor<targs{name}>(fields{local-name})
      }{}

    }
  )

  splice $ substitute(template, [
    `MainConstructor => main-constructor
    `value => gensym(`value)
    `fatal => `core/fatal])

;============================================================
;================== Printer and Writer ======================
;============================================================

;Generate the print and write instance methods for the struct.
defn printer-and-writer (form:DefStructForm) -> ? :
  val template = `(
    printer?{
      defmethod print (o:OutputStream, this) :
        val print-items = [
          fields{
            voidable?{
              if local-name is Uninitialized : "%~ = void" % [`name]
              else : "%~ = %~" % [`name, local-name]
            }{
              "%~ = %~" % [`name, local-name]
            }
          }
        ]
        print(o, "%~(%,)" % [`Struct, print-items])
    }{}

    forward-to-writer?{
      defmethod print (o:OutputStream, this) :
        write(o, this)
    }{}
    
    writer?{
      defmethod write (o:OutputStream, this) :
        val write-items = Vector<?>()
        fields{
          init?{}{
            voidable?{
              if local-name is-not Uninitialized :
                collections/add(write-items, "%~" % [local-name])
            }{
              collections/add(write-items, "%~" % [local-name])
            }
          }
        }
        print(o, "%~(%,)" % [`Struct, write-items])
    }{}
  )

  splice $ substitute(template, [
    `printer? => choice(form.printer? is True)
    `forward-to-writer? => choice(form.printer? is ForwardToWriter)
    `writer? => choice(form.writer?)
    `OutputStream => `core/OutputStream
    `Vector => `collections/Vector
    `print => `core/print
    `write => `core/write
    `print-items => gensym(`print-items)
    `write-items => gensym(`write-items)
    `o => gensym(`o)])

;============================================================
;=================== Main Constructor =======================
;============================================================

;Generates the "main constructor" for the struct.
;The main constructor is the only constructor that makes the final
;call to 'new'. All other constructors just feed arguments
;to the main constructor.
;- Arguments are allowed to be Uninitialized if they are voidable.
;- Argument preconditions are assumed to be checked already.
;- Init fields are assumed initialized and passed in.

defn main-constructor (form:DefStructForm,
                       main-constructor:Token|Symbol) -> ? :
  val template = `(
    defn MainConstructor<targs{name}> (fields{name:local-type}) :

      ;Define mutable local variables.
      fields{setter?{
        var local-name:local-type = name
      }{}}

      ;Create struct.
      new Struct<targs{name}> :

        ;Getters, setters, and updaters for each field.
        getters-setters-updaters

        ;Printer and writer
        printer-and-writer
  )

  splice $ substitute(template, [
    `MainConstructor => main-constructor,
    `getters-setters-updaters => getters-setters-updaters(main-constructor)
    `printer-and-writer => printer-and-writer(form)])

;============================================================
;=================== Simple Constructor =====================
;============================================================

;Generates the "simple constructor" for the struct.
;The simple constructor is used when the pattern satisfies
;the common case where the struct is extremely simple.
;Requirements:
;- No keyword constructor.
;- No fields with default values.
;- If any field has an updater then:
;  - No ensures.
;  - No inits.
defn simple-constructor (form:DefStructForm,
                         constructor:Symbol|Token) -> ? :

  val template = `(

    defn Constructor<targs{name}> (fields{init?{}{name:type}}) :

      ;Initialize 'init' fields.
      fields{
        init?{
          voidable?{
            var name:type
          }{
            val name:type = init-value
          }
        }{}
      }

      ;Check preconditions.
      fields{
        ensure?{
          voidable?{}{
            ;If it is not void, then check it
            #if-not-defined(OPTIMIZE) :
              ensure(description, name)
          }
        }{}
      }

      ;Define mutable local variables.
      fields{
        setter?{
          var local-name:type = name
        }{}
      }

      ;Create struct.
      new Struct<targs{name}> :

        ;Getters, setters, and updaters for each field.
        getters-setters-updaters

        ;Printer and writer
        printer-and-writer
  )

  splice $ substitute(template, [
    `Constructor => constructor
    `getters-setters-updaters => getters-setters-updaters(constructor)
    `printer-and-writer => printer-and-writer(form)])

;============================================================
;================= Positional Constructor ===================
;============================================================

;Generate the positional constructor.
defn positional-constructor (constructor:Symbol|Token,
                             main-constructor:Symbol|Token) -> ? :

  val template = `(
    defn Constructor<targs{name}> (
           fields{
             init?{}{
               arg-name:type default?{= ?}{}
             }
           }) :

      ;Compute initial values for all fields.
      fields{
        init?{
          voidable?{
            var name:type
          }{
            val name:type = init-value
          }
        }{
          default?{
            voidable?{
              var name:type
              if not empty?(arg-name) :
                name = value!(arg-name)
            }{
              val name:type =
                if empty?(arg-name) : default-value
                else : value!(arg-name)
            }
          }{
            val name:type = arg-name
          }
        }
      }

      ;Check preconditions.
      #if-not-defined(OPTIMIZE) :
        fields{
          ensure?{
            initialized?{
              ;Case: Always initialized.
              ensure(description, name)
            }{
              ;Case: Never initialized.
            }{
              ;Case: Selectively initialized.
              if not empty?(arg-name) :
                ensure(description, name)
            }
          }{}
        }

      ;Call the main constructor.
      MainConstructor<targs{name}>(
        fields{
          initialized?{
            name
          }{
            uninitialized
          }{
            value?(arg-name, uninitialized)
          }
        }
      )
  )

  splice $ substitute(template, [
    `Constructor => constructor
    `MainConstructor => main-constructor
    `empty? => `core/empty?
    `value! => `core/value!
    `value? => `core/value?])

;Generate the positional constructor with overridden
;fields bindings.
defn positional-constructor (constructor:Symbol|Token,
                             main-constructor:Symbol|Token,
                             fields:Nested) -> ? :
  splice $ substitute(`(constructor), [
    `fields => deep(fields)
    `constructor => positional-constructor(constructor, main-constructor)])

;============================================================
;================== Keyword Constructor =====================
;============================================================

;Generate the keyword constructor.
defn keyword-constructor (constructor:Symbol|Token,
                          main-constructor:Symbol|Token) -> ? :

  val template = `(
    defn Constructor<targs{name}> (--
           fields{
             init?{}{
               name:type default?{= ?}{}
             }
           }) :

      ;Store incoming arguments in arg-names.
      fields{
        init?{}{
          val arg-name = name
        }
      }

      ;Introduce new scope, so that names can be
      ;shadowed.
      let :

        ;Compute initial values for all fields.
        fields{
          init?{
            voidable?{
              var name:type
            }{
              val name:type = init-value
            }
          }{
            default?{
              voidable?{
                var name:type
                if not empty?(arg-name) :
                  name = value!(arg-name)
              }{
                val name:type =
                  if empty?(arg-name) : default-value
                  else : value!(arg-name)
              }
            }{
              val name:type = arg-name
            }
          }
        }

        ;Check preconditions.
        #if-not-defined(OPTIMIZE) :
          fields{
            ensure?{
              initialized?{
                ;Case: Always initialized.
                ensure(description, name)
              }{
                ;Case: Never initialized.
              }{
                ;Case: Selectively initialized.
                if not empty?(arg-name) :
                  ensure(description, name)
              }
            }{}
          }

        ;Call the main constructor.
        MainConstructor<targs{name}>(
          fields{
            initialized?{
              name
            }{
              uninitialized
            }{
              value?(arg-name, uninitialized)
            }
          }
        )
  )

  splice $ substitute(template, [
    `Constructor => constructor
    `MainConstructor => main-constructor
    `empty? => `core/empty?
    `value! => `core/value!
    `value? => `core/value?])

;============================================================
;=================== All Constructors =======================
;============================================================

;Generates all the constructors for the given defstruct form.
defn all-constructors (form:DefStructForm) -> ? :
  val template = `(
    simple-constructor?{
      simple-constructor
    }{
      main-constructor
      positional-constructor?{
        positional-constructor
      }{}
      keyword-constructor?{
        keyword-constructor
      }{}
    }
  )

  ;Retrieve the desired name of the constructor.
  val constructor-name = match(form.constructor.unwrap-token) :
    (c:Symbol) : form.constructor
    (c:True) : form.name
    (c:False) : false

  ;Generate the name of the main constructor.
  val main-constructor-name = gensym(form.name)

  ;Retrieve the name of the keyword constructor.
  val keyword-constructor-name = match(form.keyword-constructor.unwrap-token) :
    (c:Symbol) : form.keyword-constructor
    (c:True) : form.name
    (c:False) : false

  ;Compute the simple constructor.
  val simple-constructor =
    if form.use-simple-constructor? :
      One(simple-constructor(form, constructor-name as Token|Symbol))
    else :
      None()

  ;Compute the keyword constructor.
  val keyword-constructor =
    match(keyword-constructor-name:Symbol|Token) :
      One(keyword-constructor(keyword-constructor-name, main-constructor-name))
    else :
      None()

  ;Compute the positional constructor.
  ;Detects whether there is ambiguity case, and treats it specially.
  val positional-constructor =
    match(constructor-name:Token|Symbol) :
      if positional-vs-keyword-ambiguity?(form) :
        val new-fields = bindings(form.force-required-field, form.name)
        One $ positional-constructor(constructor-name, main-constructor-name, new-fields)
      else :
        One $ positional-constructor(constructor-name, main-constructor-name)
    else :
      None()

  splice $ substitute(template, [
    `simple-constructor? => choice(not simple-constructor.empty?)
    `simple-constructor => simple-constructor.value?
    `main-constructor => main-constructor(form, main-constructor-name)
    `keyword-constructor? => choice(not keyword-constructor.empty?)
    `keyword-constructor => keyword-constructor.value?
    `positional-constructor? => choice(not positional-constructor.empty?)
    `positional-constructor => positional-constructor.value?])

;Helper: Return true if the DefStruct form can use
;the simplified constructor.
defn use-simple-constructor? (form:DefStructForm) -> True|False :
  defn no-defaults () :
    all?({_.default.empty?}, form.fields)
  defn no-keyword-constructor () :
    form.keyword-constructor.false?
  defn any-updaters () :
    any?({not _.updater.false?}, form.fields)
  defn no-ensures () :
    all?({_.ensure.empty?}, form.fields)
  defn no-inits () :
    all?({_.init.empty?}, form.fields)

  if no-defaults() and no-keyword-constructor() :
    if any-updaters() : no-ensures() and no-inits()
    else : true

;Helper: Return true if the DefStruct form contains an ambiguous
;overlap between the positional and keyword constructor.
;Happens if there is a keyword constructor requested, and there
;exists no required fields.
defn positional-vs-keyword-ambiguity? (form:DefStructForm) -> True|False :
  ;If both constructors are requested.
  if not form.keyword-constructor.false? and
     not form.constructor.false? :

    ;If constructors have same name.
    if form.keyword-constructor.unwrap-token ==
       form.constructor.unwrap-token :

      ;No required fields?
      for f in form.fields none? :
        not f.init.empty? and
        not f.default.empty?

;Return new fields from form with one field forcibly making
;one of the fields to be required.
defn force-required-field (form:DefStructForm) -> List<StructField> :
  var processed = false
  for f in form.fields map :
    if processed or f.default.empty? :
      f
    else :
      processed = true
      f.sub-default(None())

;============================================================
;============== Main Generation Algorithm ===================
;============================================================

;Compile the entire DefStruct form.
public defn compile (form:DefStructForm) -> ? :

  val template = `(
    deftype-and-multis
    meta-utils-methods
    hashable-equalable-methods
    constructors)

  fill-template(template, [
    `Struct => deep(form.name)
    `targs => deep(repeated([`name => form.targs]))
    `fields => deep(/bindings(form.fields, form.name))
    `x => deep(gensym(`x))
    `Uninitialized => deep(`core/Uninitialized)
    `uninitialized => deep(`core/uninitialized)
    `deftype-and-multis => deftype-and-multis(form)
    `meta-utils-methods => meta-utils-methods(form)
    `hashable-equalable-methods => hashable-equalable-methods(form)
    `constructors => all-constructors(form)])

;============================================================
;================== Small Utilities =========================
;============================================================

;Returns true if x == One(`void).
defn void? (x:Maybe) -> True|False :
  x.value?.unwrap-token == `void

;Returns true if x.unwrap-token is False.
defn false? (x:Token|True|False|Symbol) -> True|False :
  x.unwrap-token is False

;Ensure no option appears more than once.
defn ensure-no-duplicate-options! (info:FileInfo|False,
                                   options:Seqable<Symbol>) :
  val keys = duplicates(options)
  if not keys.empty? :
    val keystrs = for k in keys seq: "'%~'" % [k]
    val plural-s = "s" when length(keys) > 1 else ""
    val msg = "The option%_ %, cannot be used more than once." % [plural-s, keystrs]
    throw(CSE(info, msg))

;Return all of the duplicate items in xs.
defn duplicates<?T> (xs:Seqable<?T&Equalable&Hashable>) -> Tuple<T> :
  val seen = HashSet<T>()
  val duplicates = HashSet<T>()
  for x in xs do :
    add(duplicates, x) when not add(seen, x)
  to-tuple(duplicates)