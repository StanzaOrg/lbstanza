defpackage stz/vm :
  import core
  import core/local-table
  import core/safepoints
  import core/sighandler
  import core/stack-trace
  import collections
  import stz/absolute-info
  import stz/backend
  import stz/basic-ops
  import stz/branch-table
  import stz/code-table
  import stz/code-template-table
  import stz/cvm-code-table
  import stz/dl-ir
  import stz/extern-defn-table
  import stz/extern-intrinsics
  import stz/jit-code-table
  import stz/loaded-dynamic-libraries
  import stz/packed-debug-table
  import stz/params
  import stz/stable-arrays
  import stz/timing-log-api
  import stz/trace-info
  import stz/typeset
  import stz/utils
  import stz/verbose
  import stz/vm-ids
  import stz/vm-ir
  import stz/vm-load-unit
  import stz/vm-structures
  import stz/vm-table

;<doc>=======================================================
;================= Virtual Machine Interface ================
;============================================================

# Create a virtual machine #

  val vm = VirtualMachine()

# Load new packages into the virtual machine #

  load (vm:VirtualMachine, pkgs:Collection<VMPackage>, keep-globals?:True|False) -> False

If keep-globals? is false, then new loaded globals are bound to
uninitialized variables. If keep-globals? is true, then the globals
are not changed, and retain their current value. In this case, the
globals *must* have the same type as it did previously.

# Unload the given packages from the virtual machine #

  unload (vm:VirtualMachine, pkgs:Collection<Symbol>) -> False

Unloads the given packages from the virtual machine.

# Run top-level initializers for a package #

  init-package (vm:VirtualMachine, package:Symbol)

Executes the top-level expressions in the given package.

Examples:

  init-package(vm, `core)
  init-package(vm, `repl27)

# Compute the current live records #

  compute-live (vm:VirtualMachine, exclude:Seqable<Symbol>) -> Tuple<Rec>

Example: Suppose the user wishes to reload packages stz/algorithms and
stz/parser. This means that all the global variables in these two
packages will be reset to uninitialized, and we will rerun the
top-level expressions in stz/algorithms and stz/parser.

However, there may currently exist live objects that depend upon
certain definitions in stz/algorithms and stz/parser, and we have to
be careful not to change the signatures of these definitions.

The following call will temporarily set the global variables in
stz/algorithms and stz/parser to uninitialized and then retrieve the
records depended upon by all the currently live objects in the heap.

  compute-live(vm, [`stz/algorithms, `stz/parser])

# Clear all the global variables #

  clear-globals (vm:VirtualMachine) -> False

Reset all global variables in the virtual machine to uninitialized.
This is typically used before re-executing the top-level expressions
in all packages.

;============================================================
;=======================================================<doc>

;============================================================
;======================== Timers ============================
;============================================================

val EXEC-PACKAGE = TimerLabel("VM Execute Package")
val LOAD-VM-PACKAGES = TimerLabel("VM Load Packages")
val COMPUTE-LOAD-UNIT = TimerLabel(LOAD-VM-PACKAGES, suffix("Compute Load Unit"))
val LOAD-GLOBALS = TimerLabel(LOAD-VM-PACKAGES, suffix("Load Globals"))
val LOAD-METHODS = TimerLabel(LOAD-VM-PACKAGES, suffix("Load Methods"))
val LOAD-CLASSES = TimerLabel(LOAD-VM-PACKAGES, suffix("Load Classes"))
val LOAD-FUNCTIONS = TimerLabel(LOAD-VM-PACKAGES, suffix("Load Functions"))
val LOAD-DATAS = TimerLabel(LOAD-VM-PACKAGES, suffix("Load Datas"))
val LOAD-CONSTS = TimerLabel(LOAD-VM-PACKAGES, suffix("Load Consts"))
val LOAD-CALLBACKS = TimerLabel(LOAD-VM-PACKAGES, suffix("Load Callbacks"))
val UPDATE-BRANCH-TABLE = TimerLabel(LOAD-VM-PACKAGES, suffix("Update Branch Table"))
val UPDATE-VMSTATE = TimerLabel(LOAD-VM-PACKAGES, suffix("Update VMState"))
val EXECUTE-INIT-CONSTS = TimerLabel(LOAD-VM-PACKAGES, suffix("Executing Init Consts"))

;============================================================
;======================= Linker =============================
;============================================================

deftype Linker
defmulti live-map-table (l:Linker) -> LiveMapTable
defn Linker (branch-table:BranchTable) :
  val live-map-table = LiveMapTable()
  new Linker :
    defmethod live-map-table (this) : live-map-table

;============================================================
;================= Live Map Analysis ========================
;============================================================
deftype LiveMapTable
defmulti map-index (t:LiveMapTable, slots:Seqable<Int>, num-slots:Int) -> Int
defmulti get (t:LiveMapTable, i:Int) -> LivenessMap
defmulti key? (t:LiveMapTable, i:Int) -> True|False

public defstruct LivenessMap <: Hashable&Equalable :
  live-slots: Tuple<Int>
  num-slots: Int
with:
  printer => true

defmethod hash (m:LivenessMap) :
  num-slots(m) + 7 * hash(live-slots(m))

defmethod equal? (a:LivenessMap, b:LivenessMap) :
  live-slots(a) == live-slots(b) and
  num-slots(a) == num-slots(b)

public defn LiveMapTable () :

  ;Create a canonicalized LivenessMap object.
  val sort-buffer = Vector<Int>()
  defn make-liveness-map (slots:Seqable<Int>, num-slots:Int) -> LivenessMap :
    clear(sort-buffer)
    add-all(sort-buffer, slots)
    if empty?(sort-buffer) :
      LivenessMap([], num-slots)
    else :
      qsort!(sort-buffer)
      LivenessMap(to-tuple(sort-buffer), num-slots)

  ;Accumulate all liveness maps here.
  val maps = Vector<LivenessMap>()

  ;Associate liveness maps with the index in 'maps' where they are stored.
  val table = HashTable<LivenessMap,Int>()

  ;Add a map to 'maps' and 'table'.
  defn add-map (m:LivenessMap) -> Int :
    table[m] = length(maps)
    add(maps, m)
    length(maps) - 1

  ;Add the default trivial liveness map at the first position.
  add-map(LivenessMap([], 0))

  ;Return the liven
  new LiveMapTable :
    defmethod map-index (this, slots:Seqable<Int>, num-slots:Int) :
      val map = make-liveness-map(slots, num-slots)
      match(get?(table,map)) :
        (i:Int) : i
        (f:False) : add-map(map)

    defmethod get (this, i:Int) :
      maps[i]

    defmethod key? (this, i:Int) :
      i >= 0 and i < length(maps)



;============================================================
;===================== Format Table =========================
;============================================================

public defstruct CallFormat <: Hashable&Equalable :
  xs: Tuple<VMType>
  ys: Tuple<VMType>
with :
  printer => true

defmethod hash (f:CallFormat) :
  hash(xs(f)) + 7 * hash(ys(f))
defmethod equal? (a:CallFormat, b:CallFormat) :
  xs(a) == xs(b) and ys(a) == ys(b)

public deftype FormatTable
public defmulti index (t:FormatTable, f:CallFormat) -> Int
public defmulti address (t:FormatTable, index:Int) -> Long
public defmulti get (t:FormatTable, f:CallFormat) -> Long
public defmulti set (t:FormatTable, f:CallFormat, l:Long) -> False

defn FormatTable () :
  val table = HashTable<CallFormat,Int>()
  val addresses = Vector<Long>()
  new FormatTable :
    defmethod index (this, f:CallFormat) : table[f]
    defmethod address (this, index:Int) : addresses[index]
    defmethod get (this, f:CallFormat) : addresses[table[f]]
    defmethod set (this, f:CallFormat, l:Long) :
      add(addresses, l)
      table[f] = length(addresses) - 1

public val FORMAT-TABLE = FormatTable()

;============================================================
;=================== Format Coalescing ======================
;============================================================

defn exemplar-type (t:VMType) :
  match(t:VMRef) : VMLong()
  else : t

public defn coalesce (f:CallFormat) :
  ;New return result
  val x* =
    if empty?(xs(f)) :
      VMLong()
    else :
      match(exemplar-type(xs(f)[0])) :
        (t:VMByte|VMInt) : VMLong()
        (t) : t

  ;New arguments
  val ys* = for y in ys(f) map :
    match(exemplar-type(y)) :
      (y:VMByte|VMInt) : VMLong()
      (y) : y

  ;Return coalesced call format
  CallFormat([x*], ys*)

;============================================================
;==================== Tag Bits ==============================
;============================================================

public lostanza val INT-TAG-BITS:long = 0L
public lostanza val REF-TAG-BITS:long = 1L
public lostanza val MARKER-TAG-BITS:long = 2L
public lostanza val BYTE-TAG-BITS:long = 3L
public lostanza val CHAR-TAG-BITS:long = 4L
public lostanza val FLOAT-TAG-BITS:long = 5L

public lostanza val INT-TAG-INT:ref<Int> = new Int{INT-TAG-BITS as int}
public lostanza val REF-TAG-INT:ref<Int> = new Int{REF-TAG-BITS as int}
public lostanza val MARKER-TAG-INT:ref<Int> = new Int{MARKER-TAG-BITS as int}
public lostanza val BYTE-TAG-INT:ref<Int> = new Int{BYTE-TAG-BITS as int}
public lostanza val CHAR-TAG-INT:ref<Int> = new Int{CHAR-TAG-BITS as int}
public lostanza val FLOAT-TAG-INT:ref<Int> = new Int{FLOAT-TAG-BITS as int}

;============================================================
;==================== VM Constants ==========================
;============================================================

lostanza defn untag (x:long) -> ptr<?> :
  val tagbits = x & 7L
  if tagbits != REF-TAG-BITS : fatal("Not a heap-allocated object!")
  return (x - REF-TAG-BITS + 8) as ptr<?>

lostanza defn tag (x:ptr<?>) -> long :
  return (x + REF-TAG-BITS) as long

public lostanza defn void-marker () -> long :
  return (-1L << 3L) + MARKER-TAG-BITS

public lostanza defn false-marker () -> long :
  return (FALSE-TYPE.value << 3L) + MARKER-TAG-BITS

public lostanza defn true-marker () -> long :
  return (TRUE-TYPE.value << 3L) + MARKER-TAG-BITS

public defn void-marker-int () :
  marker-int(-1)

public defn marker-int (t:Int) :
  (t << 3) + MARKER-TAG-INT

;============================================================
;=================== VM Structures ==========================
;============================================================

public lostanza deftype VirtualMachine :
  dylibs: ref<LoadedDynamicLibraries>
  extern-defns: ref<ExternDefnTable>
  backend: ref<Backend>
  vmtable: ref<VMTable>
  vm-ids: ref<VMIds>
  linker: ref<Linker>
  vmstate: ptr<VMState>
  var core-loaded?: ref<True|False>

lostanza defn linker (vm:ref<VirtualMachine>) -> ref<Linker> :
  return vm.linker

lostanza defn vm-ids (vm:ref<VirtualMachine>) -> ref<VMIds> :
  return vm.vm-ids

lostanza defn vmtable (vm:ref<VirtualMachine>) -> ref<VMTable> :
  return vm.vmtable

lostanza defn class-table (vm:ref<VirtualMachine>) -> ref<ClassTable> :
  return vmtable(vm).class-table

lostanza defn backend (vm:ref<VirtualMachine>) -> ref<Backend> :
  return vm.backend

lostanza defn live-map-table (vm:ref<VirtualMachine>) -> ref<LiveMapTable> :
  return live-map-table(linker(vm))

lostanza defn dynamic-libraries (vm:ref<VirtualMachine>) -> ref<LoadedDynamicLibraries> :
  return vm.dylibs

lostanza defn extern-defns (vm:ref<VirtualMachine>) -> ref<ExternDefnTable> :
  return vm.extern-defns

lostanza defn update-vmstate (vm:ref<VirtualMachine>) -> ref<False> :
  val vms = vm.vmstate
  val vmt = vmtable(vm)
  vms.instructions = instructions(vmt.code-table).value as ptr<byte>
  vms.global-offsets = vmt.global-offsets.data
  vms.global-mem = vmt.globals.mem
  vms.const-table = vmt.consts.mem
  vms.const-mem = vmt.consts-data.mem
  vms.data-offsets = vmt.data-positions.data
  vms.data-mem = vmt.data.mem
  vms.code-offsets = vmt.function-addresses.data
  vms.trie-table = trie-table-data(branch-table(vm))
  vms.class-table = packed-class-table(vmt.class-table)
  return false

;============================================================
;==================== VM Implementation =====================
;============================================================

public defn VirtualMachine (dylibs:LoadedDynamicLibraries) :
  #if-defined(PLATFORM-WINDOWS) :
    VirtualMachine(dylibs, W64Backend())
  #else :
    #if-defined(PLATFORM-LINUX) :
      VirtualMachine(dylibs, L64Backend())
    #else :
      VirtualMachine(dylibs, X64Backend())

public lostanza defn VirtualMachine (dylibs:ref<LoadedDynamicLibraries>, backend:ref<Backend>) -> ref<VirtualMachine> :
  val vmstate:ptr<VMState> = call-c clib/malloc(sizeof(VMState))
  vmstate.registers = call-c clib/malloc(8 * 256)
  vmstate.system-registers = call-c clib/malloc(8 * 256)
  ;Initialize heap
  val initial-heap-size = 8 * 1024L * 1024L
  val heap = addr(vmstate.heap)
  initialize-heap(heap, initial-heap-size, MAXIMUM-HEAP-SIZE)
  heap.iterate-roots = addr(vm-iterate-roots)
  heap.iterate-references-in-stack-frames = addr(vm-iterate-references-in-stack-frames)

  ;Initialize sighandler to false to indicate no handler on initialization.
  vmstate.sig-handler = false-marker()

  ;Initialize extern trampoline
  initialize-extern-trampoline(addr(call_extern), vmstate.registers)

  vmstate.trie-table = null
  vmstate.class-table = null
  vmstate.debug-table = no-debug-table()
  vmstate.safepoint-table = no-safepoint-table()
  vmstate.local-var-table = no-local-vars-table()
  val extern-defns = ExternDefnTable(backend)
  val vm-ids = VMIds(dylibs, extern-defns)
  val class-table = ClassTable()
  val branch-table = BranchTable(class-table)
  val linker = Linker(branch-table)
  val resolver = EncodingResolver(class-table, branch-table, live-map-table(linker), dylibs, extern-defns)
  val code-table = make-code-table(resolver, backend)
  val vmtable = VMTable(class-table, branch-table, code-table)
  val vm = new VirtualMachine{dylibs, extern-defns, backend, vmtable, vm-ids, linker, vmstate, false}
  update-vmstate(vm)
  return vm

lostanza defn no-debug-table () -> ptr<?> :
  val p:ptr<long> = call-c clib/malloc(sizeof(long))
  [p] = 0 ;num-packages field is immutable
  return p
lostanza defn no-safepoint-table () -> ptr<?> :
  val p:ptr<long> = call-c clib/malloc(sizeof(SafepointTable))
  [p] = 0 ;num-files field is immutable
  return p
lostanza defn no-local-vars-table () -> ptr<?> :
  val p:ptr<?> = call-c clib/malloc(sizeof(LSLocalVarTable))
  val limit:ptr<?> = p + sizeof(LSLocalVarTable)
  for (var q:ptr<ptr<?>> = p, q < limit, q = q + sizeof(ptr<?>)) :
    [q] = zero-length-container()
  return p
lostanza defn zero-length-container () -> ptr<?> :
  val p:ptr<long> = call-c clib/malloc(sizeof(long))
  [p] = 0 ;length field, either long or int
  return p

;Make an appropriate CodeTable depending on whether the user has
;enabled the JIT.
defn make-code-table (resolver:EncodingResolver, backend:Backend) -> CodeTable :
  if contains?(EXPERIMENTAL-FEATURES, `jit) : JITCodeTable(resolver, backend)
  else : CVMCodeTable()

lostanza defn vm-iterate-roots (f:ptr<((ptr<long>, ptr<core/VMState>) -> ref<False>)>,
                                vms:ptr<core/VMState>) -> ref<False> :
  val vmtable = vmtable(current-vm())
  ;Scan globals
  val globals:ptr<long> = vmtable.globals.mem
  val roots = to-seq(roots(vmtable.global-table))
  while empty?(roots) == false :
    val r = next(roots).value
    [f](addr(globals[r]), vms)
  ;Scan const roots
  val consts:ptr<long> = vmtable.consts.mem
  val nconsts = vmtable.consts.size / 8
  for (var i:int = 0, i < nconsts, i = i + 1) :
    [f](addr(consts[i]), vms)
  ;No meaningful return value
  return false

lostanza defn vm-iterate-references-in-stack-frames (stack:ptr<Stack>,
                                                     f:ptr<((ptr<long>, ptr<core/VMState>) -> ref<False>)>,
                                                     vms:ptr<core/VMState>) -> ref<False> :
  val live-maps = live-map-table(current-vm())
  ;Precondition: stack.frames != null
  var frame:ptr<StackFrame> = stack.frames
  val end-frame:ptr<StackFrame> = stack.stack-pointer
  while frame <= end-frame :
    val map = get(live-maps, new Int{frame.liveness-map as int})
    val live-slots = live-slots(map)
    val num-live = length(live-slots).value
    for (var i:int = 0, i < num-live, i = i + 1) :
      val r = get(live-slots, new Int{i}).value
      [f](addr(frame.slots[r]), vms)
    frame = addr(frame.slots[num-slots(map).value]) as ptr<StackFrame>
  ;No meaningful return value
  return false

;============================================================
;================= Bytecode Loop ============================
;============================================================

protected extern defn call_garbage_collector (vms:ptr<VMState>, size:long) -> long :
  return extend-heap(current-vm(), size)

protected extern defn call_print_stack_trace (vms:ptr<VMState>, stack:long) -> int :
  val vm = current-vm()
  val stk:ptr<Stack> = untag(stack)
  print-stack-trace(stk, vmtable(vm), live-map-table(vm))
  return 0

protected extern defn call_collect_stack_trace (vms:ptr<VMState>, stack:long) -> ptr<PackedStackTrace> :
  val vm = current-vm()
  val stk:ptr<Stack> = untag(stack)
  return collect-stack-trace(stk, vmtable(vm), live-map-table(vm))

;Run the given virtual machine starting from the given starting function.
var VIRTUAL-MACHINE : VirtualMachine|False = false
protected lostanza var register-array:ptr<long>

lostanza defn current-vm () -> ref<VirtualMachine> :
  return VIRTUAL-MACHINE as ref<VirtualMachine>

lostanza defn heap (vm:ref<VirtualMachine>) -> ptr<core/Heap> :
  return addr!(vm.vmstate.heap)

lostanza defn current-stack (vm:ref<VirtualMachine>) -> ptr<Stack> :
  return untag(heap(vm).current-stack)

public lostanza defn run-bytecode (vm:ref<VirtualMachine>, start-func:ref<Int>) -> ref<False> :
  VIRTUAL-MACHINE = vm
  register-array = vm.vmstate.registers
  initialize-stack-pointer(vm)
  launch(new Long{vm.vmstate as long}, vm.vmtable.code-table, start-func)
  null-stack-pointer(vm)
  VIRTUAL-MACHINE = false
  return false

;Called by the extern defn callbacks defined in the generated bindings
extern defn call_extern (func-id:int) -> int :
  ;Retrieve the currently active virtual machine
  val vm = current-vm()
  ;Set the returnpc to -1, so that execution will return here.
  var saved-ret:long
  let :
    val stk:ptr<Stack> = current-stack(vm)
    val sp = stk.stack-pointer
    saved-ret = sp.return
    sp.return = -1
  ;Execute from startin function
  launch(new Long{vm.vmstate as long}, vm.vmtable.code-table, new Int{func-id})
  ;Restore the returnpc and return
  let :
    val stk:ptr<Stack> = current-stack(vm)
    val sp = stk.stack-pointer
    sp.return = saved-ret
    return 0

;Called by the extern defn callbacks. Retrieve the registers array
;from the currently active virtual machine.
public lostanza defn vm-registers () -> ptr<long> :
  return current-vm().vmstate.registers

;Set the stack pointer of the stack to point to the beginning
;of its frames. (I.e. It is no longer null.)
lostanza defn initialize-stack-pointer (vm:ref<VirtualMachine>) -> ref<False> :
  val stk:ptr<Stack> = current-stack(vm)
  stk.stack-pointer = stk.frames
  return false

;Set the stack pointer of the stack to null. (I.e. It is no longer active.)
lostanza defn null-stack-pointer (vm:ref<VirtualMachine>) -> ref<False> :
  val stk:ptr<Stack> = current-stack(vm)
  stk.stack-pointer = null
  return false

;============================================================
;==================== Dispatch ==============================
;============================================================

lostanza defn branch-table (vm:ref<VirtualMachine>) -> ref<BranchTable> :
  return vmtable(vm).branch-table

;============================================================
;===================== Stack Traces =========================
;============================================================

;------------------------------------------------------------
;---------------------- Printing ----------------------------
;------------------------------------------------------------

lostanza defn print-stack-trace (stack:ptr<Stack>, vmtable:ref<VMTable>, livemap:ref<LiveMapTable>) -> ref<False> :
  ;Collect entries
  val buffer = collect-stack-trace-entries(stack, vmtable, livemap)

  ;Print out the entries
  print-stack-buffer(buffer)

  ;Return false
  return false

;Print the stack buffer
defn print-stack-buffer (buffer:Vector<StackTraceEntry>) -> False :
  do(print-stack-entry, buffer)

;Print a single stack trace entry.
defn print-stack-entry (e:StackTraceEntry) -> False :
  ;Print package and signature
  match(signature(e)) :
    (sig:String) : println(STANDARD-ERROR-STREAM, "  in %_/%_" % [package(e), sig])
    (sig:False) : println(STANDARD-ERROR-STREAM, "  in %_" % [package(e)])
  ;Print file information
  match(info(e)) :
    (info:AbsoluteFileInfo) : println(STANDARD-ERROR-STREAM, "    at %_" % [/info(info)])
    (f:False) : false

;------------------------------------------------------------
;---------------------- Collecting --------------------------
;------------------------------------------------------------


lostanza defn collect-stack-trace (stack:ptr<Stack>, vmtable:ref<VMTable>, livemap:ref<LiveMapTable>) -> ptr<PackedStackTrace> :
  return pack(collect-stack-trace-entries(stack, vmtable, livemap))

;Pack items into stable memory.
lostanza defn pack (buffer:ref<Vector<StackTraceEntry>>) -> ptr<PackedStackTrace> :
  val builder = StackTraceBuilder()
  add-entries(builder, buffer)
  return pack(builder)
defn add-entries (b:StackTraceBuilder, es:Seqable<StackTraceEntry>) :
  for e in es do :
    add-entry(b, e)

public lostanza defn collect-current-stack-trace (vm:ref<VirtualMachine>) -> ref<SingleStackTrace> :
  val buffer = collect-current-stack-trace-entries(current-stack(vm), vmtable(vm), live-map-table(vm))
  return new SingleStackTrace{pack(buffer)}

;------------------------------------------------------------
;-------------------- Common Utilities ----------------------
;------------------------------------------------------------

lostanza defn collect-stack-trace-entries (stack:ptr<Stack>,
                                           vmtable:ref<VMTable>,
                                           livemap:ref<LiveMapTable>) -> ref<Vector<StackTraceEntry>> :
  val trace-table = vmtable.trace-table
  ;Accumulate all entries into a buffer.
  val buffer = Vector<StackTraceEntry>()
  ;Discover return addresses
  val end-sp = stack.stack-pointer
  labels :
    begin : goto loop(stack.frames)
    loop (sp:ptr<StackFrame>) :
      add-entry(buffer, new Long{sp.return}, new Long{sp as long}, trace-table)

      ;Continue if we're not at the end of the stack
      if sp < end-sp :
        val map-index = sp.liveness-map as int
        val stackmap = get(livemap, new Int{map-index})
        val num-slots = num-slots(stackmap).value
        val next-frame = addr(sp.slots[num-slots]) as ptr<StackFrame>
        goto loop(next-frame)
  reverse!(buffer)
  return buffer
defn add-entry (buffer:Vector<StackTraceEntry>, pc:Long, sp:Long, trace-table:HashTable<Long,StackTraceInfo>) :
  val st-info = get?(trace-table, pc)
  ;Store in the buffer if it exists in the stack trace table
  match(st-info:StackTraceInfo) :
    add(buffer, StackTraceEntry(pc, sp, package(st-info), signature(st-info), info(st-info)))

lostanza defn collect-current-stack-trace-entries (stack:ptr<Stack>,
                                                   vmtable:ref<VMTable>,
                                                   livemap:ref<LiveMapTable>) -> ref<Vector<StackTraceEntry>> :
  val trace-table = vmtable.trace-table
  ;Accumulate all entries into a buffer.
  val buffer = Vector<StackTraceEntry>()
  ;Discover return addresses
  val end-sp = stack.stack-pointer
  labels :
    begin : goto loop(stack.frames)
    loop (sp:ptr<StackFrame>) :
      ;Continue if we're not at the end of the stack
      if sp < end-sp :
        add-entry(buffer, new Long{sp.return}, new Long{sp as long}, trace-table)

        val map-index = sp.liveness-map as int
        val stackmap = get(livemap, new Int{map-index})
        val num-slots = num-slots(stackmap).value
        val next-frame = addr(sp.slots[num-slots]) as ptr<StackFrame>
        goto loop(next-frame)
      else :
        add-entry(buffer, get-sighandler-instruction-address(), new Long{sp as long}, trace-table)
  ;Return the vector of entries in reverse order
  reverse!(buffer)
  return buffer

;============================================================
;==================== Heap/Stack Extension ==================
;============================================================

;This function is called by the C virtual machine when interpreting
;a GC_OPCODE instruction. It returns the new number of remaining bytes
;on the heap.
lostanza defn extend-heap (vm:ref<VirtualMachine>, size:long) -> long :
  val saved-vm = VIRTUAL-MACHINE
  VIRTUAL-MACHINE = vm
  val available-bytes = collect-garbage(size, vm.vmstate as ptr<core/VMState>)
  VIRTUAL-MACHINE = saved-vm
  return available-bytes

lostanza defn ensure-heap-space (vm:ref<VirtualMachine>, size:long) -> ref<False> :
  val saved-vm = VIRTUAL-MACHINE
  VIRTUAL-MACHINE = vm
  ensure-heap-space(size + sizeof(long), vm.vmstate as ptr<core/VMState>)
  VIRTUAL-MACHINE = saved-vm
  return false

lostanza defn object-size-on-heap (sz:ref<Int>) -> ref<Int> :
  return new Int{object-size-on-heap(sz.value) as int}

lostanza defn num-slots (f:ptr<StackFrame>, vm:ref<VirtualMachine>) -> int :
  val map = get(live-map-table(vm), new Int{f.liveness-map as int})
  return num-slots(map).value

;============================================================
;==================== Liveness Detector =====================
;============================================================

val EMPTY-TUPLE = []
public lostanza defn compute-live (vm:ref<VirtualMachine>, exclude:ref<Seqable<Symbol>>) -> ref<Tuple<Rec>> :
  ;If virtual machine is not yet initialized, then return empty tuple.
  if vm.core-loaded? == false : return EMPTY-TUPLE

  ;Save VIRTUAL-MACHINE and set it to given vm. It is necessary for GC functions.
  val saved-vm = VIRTUAL-MACHINE
  VIRTUAL-MACHINE = vm

  ;Perform full GC to get rid of unreachable stacks and liveness-tracked objects
  val vms = vm.vmstate as ptr<core/VMState>
  val heap = addr(vms.heap)
  full-heap-collection(vms)

  ;Scan global roots
  val vmtable = vmtable(vm)
  val globals:ptr<long> = vmtable.globals.mem
  val roots = to-seq(roots(vmtable.global-table, exclude))
  while empty?(roots) == false :
    val i = next(roots).value
    mark-from-root(addr(globals[i]), vms)
  ;Const roots do not affect liveness

  ;Scan stack roots assuming all heap's stacks are live. It may be too conservative.
  ;Superfluous dependencies can be added to the set. In this case, consider performing full GC
  ;first to get rid of dead stacks.
  for (var stack:ptr<Stack> = heap.stacks, stack != null, stack = stack.tail) :
    val stack-obj = stack as ptr<?> - sizeof(long)
    set-mark(stack-obj, heap)
    iterate-references-in-stack-frames(stack, addr(mark-from-root), vms)

  ;Scan liveness trackers assuming all heap's liveness-tracked objects are live.
  ;Superfluous dependencies can be added to the set. In this case, consider performing full GC
  ;first to get rid of dead stacks.
  for (var tracker:ptr<LivenessTracker> = heap.liveness-trackers, tracker != null, tracker = tracker.tail) :
    val tracker-obj = tracker as ptr<?> - sizeof(long)
    set-mark(tracker-obj, heap)
    val value-obj = (tracker.value - 1) as ptr<?>
    set-mark(value-obj, heap)

  complete-marking(vms)

  ;Get live set
  val live-recs = RecSet()
  val vm-ids = vm-ids(vm)
  val heap-top = heap.top
  for (var p:ptr<long> = heap.start, p < heap.old-objects-end, p = p + allocation-size(p, vms)) :
    if test-and-clear-mark(p, heap) != 0 :
      val tag = [p] as int
      if tag == FN-TYPE.value :
        val f = (p + sizeof(long)) as ptr<Function>
        val code = new Int{f.code as int}
        add-all(live-recs, function-dependencies(vm-ids, code))
      else :
        add-all(live-recs, class-dependencies(vm-ids, new Int{tag}))
  ;Restore VIRTUAL-MACHINE
  VIRTUAL-MACHINE = saved-vm
  ;Return ids
  return to-tuple(live-recs)

defn RecSet () :
  HashSet<Rec>(hash{id(_)}, {id(_) == id(_)})

;============================================================
;===================== Debugging ============================
;============================================================

lostanza defn dump-heap (vm:ref<VirtualMachine>) -> ref<False> :
  val heap = heap(vm)
  call-c clib/printf("Heap[%p to %p]:\n", heap.start, heap.old-objects-end)
  dump-heap(heap.start, heap.old-objects-end, vm)
  call-c clib/printf("Nursery[%p to %p]:\n", core/nursery-start(heap), heap.top)
  dump-heap(core/nursery-start(heap), heap.top, vm)
  return false

lostanza defn dump-heap (pstart:ptr<long>, pend:ptr<long>, vm:ref<VirtualMachine>) -> int :
  val stackrefs = Vector<Long>()
  call-c clib/printf("Heap:\n")
  val class-table = class-table(vm)
  var p:ptr<long> = pstart
  while p < pend :
    val tag = [p] as int
    if tag == STACK-TYPE.value :
      add(stackrefs, new Long{/tag(p)})
    val class = get(class-table, new Int{tag})
    match(class) :
      (class:ref<VMLeafClass>) :
        val obj = p as ptr<ObjectLayout>
        val size = size(class).value
        call-c clib/printf("  %p: [Object %d, size = %d]", /tag(p), tag, size)
        for (var i:long = 0, i < size, i = i + 8) :
          call-c clib/printf("  %lx", [p + 8 + i])
        call-c clib/printf("\n")
        ;Advance to next object
        p = p + object-size-on-heap(size)
      (class:ref<VMArrayClass>) :
        val array = p as ptr<ObjectLayout>
        val len = array.slots[0]
        val base-size = base-size(class).value
        val item-size = item-size(class).value
        val size = base-size + item-size * len
        call-c clib/printf("  %p: [Array %d, length = %ld, base-size = %d, item-size = %d]",
                           /tag(p), tag, len, base-size, item-size)
        for (var i:long = 0, i < size, i = i + 8) :
          call-c clib/printf("  %lx", [p + 8 + i])
        call-c clib/printf("\n")
        ;Advance to next object
        p = p + object-size-on-heap(size)
  ;Dump stacks
  val stackrefs-length = length(stackrefs).value
  for (var i:int = 0, i < stackrefs-length, i = i + 1) :
    val s = get(stackrefs, new Int{i})
    dump-stack(s.value, vm)
  return 0

lostanza defn dump-stack (stackref:long, vm:ref<VirtualMachine>) -> int :
  val stk:ptr<Stack> = untag(stackref)
  var f:ptr<StackFrame> = stk.frames
  val f-end = stk.stack-pointer
  call-c clib/printf("Stack %p:\n", stackref)
  if f != null :
    val live-map-table = live-map-table(vm)
    while f <= f-end :
      ;Get frame properties
      val map-index = new Int{f.liveness-map as int}
      if key?(live-map-table, map-index) == true :
        val map = get(live-map-table, map-index)
        val live-slots = live-slots(map)
        val num-slots = num-slots(map).value
        ;Print properties
        val num-live = length(live-slots).value
        var slot-i:int = 0
        call-c clib/printf("  %p: [StackFrame %ld, num-slots = %d]\n", f, f.liveness-map, num-slots)
        for (var i:int = 0, i < num-slots, i = i + 1) :
          if slot-i < num-live and live-slots.items[slot-i].value == i :
            call-c clib/printf("    %d: [%lx]\n", i, f.slots[i])
            slot-i = slot-i + 1
          else :
            call-c clib/printf("    %d: %lx\n", i, f.slots[i])
        ;Advance to next frame
        f = addr(f.slots[num-slots]) as ptr<StackFrame>
      else :
        call-c clib/printf("  %p: [BAD FRAME %x]\n", f, f.liveness-map)
        return 0
  return 0

lostanza defn print-tag (ref:long) -> int :
  call-c clib/printf("inspect tag of %p\n", ref)
  val tagbits = ref & 7L
  if tagbits == REF-TAG-BITS :
    val tag = [(ref - REF-TAG-BITS) as ptr<long>]
    if tag == FN-TYPE.value or tag == TYPE-TYPE.value :
      val f:ptr<Function> = untag(ref)
      call-c clib/printf("tagbits = %ld (REF), tag = %ld (FN/TYPE), code = %ld\n", tagbits, tag, f.code)
    else :
      call-c clib/printf("tagbits = %ld (REF), tag = %ld\n", tagbits, tag)
  else if tagbits == MARKER-TAG-BITS :
    val tag = ref >> 3L
    call-c clib/printf("tagbits = %ld (MARKER), tag = %ld\n", tagbits, tag)
  else if tagbits == INT-TAG-BITS :
    call-c clib/printf("tagbits = %ld (INT)\n", tagbits)
  else if tagbits == BYTE-TAG-BITS :
    call-c clib/printf("tagbits = %ld (BYTE)\n", tagbits)
  else if tagbits == CHAR-TAG-BITS :
    call-c clib/printf("tagbits = %ld (CHAR)\n", tagbits)
  else if tagbits == FLOAT-TAG-BITS :
    call-c clib/printf("tagbits = %ld (FLOAT)\n", tagbits)
  else :
    call-c clib/printf("Unrecognized tag bits.\n")
  return 0

lostanza defn function-addresses (vmt:ref<VMTable>) -> ref<StableLongArray> :
  return vmt.function-addresses

public defn class-name (id:Int, vm:VirtualMachine) :
  match(class-table(vm)[id]) :
    (class:VMLeafClass) : name(class)
    (class:VMArrayClass) : name(class)

;============================================================
;================= Instruction Encoding =====================
;============================================================

defn EncodingResolver (class-table:ClassTable,
                       branch-table:BranchTable,
                       live-map-table:LiveMapTable,
                       dylibs:LoadedDynamicLibraries,
                       extern-defns:ExternDefnTable) :
  new EncodingResolver :
    defmethod liveness-map (this, live:Seqable<Int>, num-locals:Int) :
      map-index(live-map-table, live, num-locals)
    defmethod object-header-size (this) :
      8
    defmethod object-size-on-heap (this, sz:Int) :
      object-size-on-heap(sz) - 8
    defmethod dispatch-format (this, branches:Tuple<Tuple<TypeSet>>) :
      add(branch-table, DispatchFormat(branches))
    defmethod match-format (this, branches:Tuple<Tuple<TypeSet>>) :
      add(branch-table, MatchFormat(branches))
    defmethod method-format (this, multi:Int, num-header-args:Int, num-args:Int) :
      add(branch-table, MultiFormat(multi, num-header-args, num-args))
    defmethod marker (this, type:Int) : marker-int(type)
    defmethod void-marker (this) : void-marker-int()
    defmethod ref-offset (this) : REF-TAG-INT
    defmethod type-is-final? (this, n:Int) :
      val c = loaded-class(class-table, n)
      match(class(c)) :
        (class:VMArrayClass|VMLeafClass) : package(c) == `core
        (class) : false
    defmethod marker? (this, n:Int) :
      match(class-table[n]) :
        (c:VMLeafClass) : size(c) == 0 and not unique?(class-table,n)
        (c) : false
    defmethod tagbits (this, n:Int) :
      switch(n) :
        BYTE-TYPE : BYTE-TAG-INT
        CHAR-TYPE : CHAR-TAG-INT
        INT-TYPE : INT-TAG-INT
        FLOAT-TYPE : FLOAT-TAG-INT
    defmethod extern-address (this, id:Int) :
      extern-address(dylibs, id)
    defmethod extern-defn-address (this, id:Int) :
      address-as-long(extern-defns, id)

;============================================================
;====================== Loading =============================
;============================================================

public defn load (vm:VirtualMachine, vmps:Collection<VMPackage>, keep-existing-globals?:True|False) -> False :
  if not empty?(to-seq(vmps)) :
    vprintln("VM: Load packages %," % [seq(name, vmps)])
    val package-names = to-string("%," % [seq(name, vmps)])
    within log-time(LOAD-VM-PACKAGES, suffix(package-names)) :
      ;Precondition
      ensure-core-loaded-first!(vm, vmps)

      ;Retrieve tables
      vprintln("VM: Computing load unit.")
      val vmt = vmtable(vm)
      val vm-ids = vm-ids(vm)
      val load-unit = within log-time(COMPUTE-LOAD-UNIT) :
        load-packages(vm-ids, vmps)

      ;Load all packages
      vprintln("VM: Loading packages")
      for p in packages(load-unit) do :
        vprintln("VM: Loading package %_" % [name(p)])
        within log-time(LOAD-GLOBALS) :
          load-globals(vmt, globals(p), name(p), keep-existing-globals?)
        within log-time(LOAD-METHODS) :
          load-package-methods(branch-table(vm), name(p), methods(p))

      ;Load all classes into table
      vprintln("VM: Loading classes")
      within log-time(LOAD-CLASSES) :
        load-classes(vmt, classes(load-unit))

      ;Load callbacks
      ;This has to be done before loading functions so that ExternDefnId
      ;can be resolved to the right addresses.
      vprintln("VM: Loading callbacks")
      within log-time(LOAD-CALLBACKS) :
        for c in callbacks(load-unit) do :
          set-signature(extern-defns(vm), index(c), function-id(c), a1(c), a2(c))

      ;Map safepoint id to its addr
      val safepoint-map = Array<Vector<Long>>(max-safepoint-id(load-unit))
      for i in 0 to length(safepoint-map) do :
        safepoint-map[i] = Vector<Long>()

      val local-table-packer = LocalTablePacker()

      ;Load functions
      vprintln("VM: Encoding functions")
      within log-time(LOAD-FUNCTIONS) :
        ;Compute the functions that are exposed externally via callbacks.
        val callback-set = to-intset(seq(function-id, callbacks(load-unit)))
        ;Create the encoding resolver for compiling the function.
        val encoding-resolver = EncodingResolver(class-table(vm), branch-table(vm), live-map-table(linker(vm)),
                                                 dynamic-libraries(vm), extern-defns(vm))
        ;Load each of the functions.
        for f in funcs(load-unit) do :
          val loaded-function = load-function(vmt, f, callback-set[id(f)], encoding-resolver, backend(vm))
          for safepoint-entry in safepoint-entries(loaded-function) do:
            add(safepoint-map[id(safepoint-entry)], pc(safepoint-entry))
          add(local-table-packer, local-var-context(loaded-function), local-var-map-entries(loaded-function))

      ;Load datas and consts
      vprintln("VM: Loading datas and constants")
      within log-time(LOAD-DATAS) :
        load-datas(vmt, datas(load-unit))
      within log-time(LOAD-CONSTS) :
        load-consts(vmt, consts(load-unit))

      ;Update the virtual machine state
      vprintln("VM: Updating branch table")
      within log-time(UPDATE-BRANCH-TABLE) :
        update(branch-table(vm))
      vprintln("VM: Updating VMState")
      within log-time(UPDATE-VMSTATE) :
        update-vmstate(vm)

      vprintln("VM: Building debug table")
      dispose-debug-table(vm)
      pack(debug-table(load-unit), vm)

      vprintln("VM: Building local var table")
      dispose-local-var-table(vm)
      pack(local-table-packer, vm)

      vprintln("VM: Building safepoint table")
      dispose-safepoints(vm)
      pack(safepoints(load-unit), safepoint-map, vm)

      ;If core has been loaded, then initialize the constants by running
      ;the initialize-constants function.
      if core-loaded?(vm) :
        vprintln("VM: Run constant initializer.")
        within log-time(EXECUTE-INIT-CONSTS) :
          run-bytecode(vm, INIT-CONSTS-FN)
        vprintln("VM: Finished running constant initializer.")

public defn unload (vm:VirtualMachine, ps:Collection<Symbol>) :
  val vmps = to-tuple $ for p in ps seq :
    val io = PackageIO(p, [], [], [], false)
    VMPackage(io, false, [], [], [], [], [], [], [], [], , VMDebugNameTable([]), VMDebugInfoTable([]), VMSafepointTable([]))
  load(vm, vmps, false)

defn ensure-core-loaded-first! (vm:VirtualMachine, vmps:Collection<VMPackage>) :
  if not core-loaded?(vm) :
    val package-names = to-tuple(seq(name, vmps))
    if not contains?(package-names, `core) :
      fatal("Cannot load packages %, before loading core." % [package-names])
lostanza defn core-loaded? (vm:ref<VirtualMachine>) -> ref<True|False> :
  return vm.core-loaded?
lostanza defn set-core-loaded? (vm:ref<VirtualMachine>, v:ref<True|False>) -> ref<False> :
  vm.core-loaded? = v
  return false

public defn init-package (vm:VirtualMachine, package:Symbol) -> True|False :
  vprintln("VM: Initializating package %_" % [package])
  val f = package-init(vm-ids(vm), package)
  match(f:Int) :
    vprintln("VM: Running package %_" % [package])
    within log-time(EXEC-PACKAGE, suffix(package)) :
      val run-result =
        if package == `core :
          run-bytecode(vm, f)
          set-core-loaded?(vm, true)
          true
        else :
          launch-init(vm, f)
      vprintln("VM: Finished running package %_" % [package])
      run-result
  else :
    vprintln("VM: Package %_ contains no top-level code." % [package])
    true

public lostanza defn clear-globals (vm:ref<VirtualMachine>) -> ref<False> :
  ;Scan global roots
  val vmtable = vmtable(vm)
  val globals:ptr<long> = vmtable.globals.mem
  val roots = to-seq(roots(vmtable.global-table))
  while empty?(roots) == false :
    val i = next(roots).value
    globals[i] = void-marker()
  return false

lostanza defn dispose-debug-table (vm:ref<VirtualMachine>) -> ref<False> :
  val vms:ptr<VMState> = vm.vmstate
  val debug-table = vms.debug-table
  vms.debug-table = null
  call-c clib/free(debug-table)
  return false

;============================================================
;==================== Safepoint Table =======================
;============================================================

;Preconditions (guarenteed by vm-ids):
;- VMFileSafepoints with duplicate filenames are merged
;- VMInfoEntries are sorted by line number in each VMFieSafepoints
defn pack (safepoint-table:Tuple<VMFileSafepoints>, locations:Array<Vector<Long>>, vm:VirtualMachine) -> False :
  val safepoints = compact(safepoint-table, locations)
  val table = start-safepoint-table(length(safepoints))
  for file-safepoints in safepoints do :
    val entries = entries(file-safepoints)
    val file = start-file-safepoints(filename(file-safepoints), count-lines(entries))
    var i = 0
    val entries-length = length(entries)
    while i < entries-length :
      val current-line = line(entries[i])
      var next = i
      var count = 0
      while next < entries-length and current-line == line(entries[next]) :
        val id = id(entries[next])
        count = count + length(locations[id])
        next = next + 1
      val address-list = create-address-list(count)
      while i < next :
        val entry = entries[i]
        val group = group(entry)
        for loc in locations[id(entry)] do :
          append-safepoint-address(address-list, loc, group)
        i = i + 1
      append-entry(file, current-line, address-list)
    finish-file-safepoints(table, file)
  finish-safepoint-table(table, vm)

defn compact (safepoints:Tuple<VMFileSafepoints>, locations:Array<Vector<Long>>) :
  ;Are there any unreferenced safepoint entries?
  if empty?(safepoints) or find(empty?, locations) is False :
    safepoints
  else :
    val new-file-safepoints = Vector<VMFileSafepoints>(length(safepoints))
    defn unreferenced? (entry:VMSafepointInfo) : empty?(locations[id(entry)])
    for file in safepoints do :
      val entries = entries(file)
      if not empty?(entries) :
        ;Any unreferenced entries?
        if find(unreferenced?, entries) is False :
          add(new-file-safepoints, file)
        else :
          val new-entries = Vector<VMSafepointInfo>(length(entries))
          for entry in entries do :
            if not unreferenced?(entry) :
              add(new-entries, entry)
          if not empty?(new-entries) :
            val new-file = VMFileSafepoints(base(file), filename(file), to-tuple(new-entries))
            add(new-file-safepoints, new-file)
    to-tuple(new-file-safepoints)

lostanza defn start-safepoint-table (length:ref<Int>) -> ref<BinaryEmitter> :
  val num-files = length.value
  val emitter = make-binary-emitter(sizeof(SafepointTable) + num-files * sizeof(ptr<FileSafepoints>))
  emit-long(emitter, num-files)
  return emitter
lostanza defn finish-safepoint-table (emitter:ref<BinaryEmitter>, vm:ref<VirtualMachine>) -> ref<False> :
  vm.vmstate.safepoint-table = emitter.start
  return false

extern strdup: ptr<byte> -> ptr<byte>
lostanza defn start-file-safepoints (name:ref<String>, length:ref<Int>) -> ref<BinaryEmitter> :
  val num-entries = length.value as long
  val filename = call-c strdup(addr!(name.chars))
  val emitter = make-binary-emitter(sizeof(FileSafepoints) + num-entries * sizeof(SafepointEntry))
  emit-long(emitter, num-entries)
  emit(emitter, filename)
  return emitter
lostanza defn finish-file-safepoints (table:ref<BinaryEmitter>, file:ref<BinaryEmitter>) -> ref<False> :
  return emit(table, file.start)
lostanza defn append-entry (file:ref<BinaryEmitter>, line:ref<Int>, address-list:ref<BinaryEmitter>) -> ref<False> :
  emit-long(file, line.value)
  return emit(file, address-list.start)
lostanza defn create-address-list (length:ref<Int>) -> ref<BinaryEmitter> :
  val len = length.value as long
  val emitter = make-binary-emitter(sizeof(AddressList) + len * sizeof(SafepointAddress))
  emit-long(emitter, len)
  return emitter
lostanza defn append-safepoint-address (address-list:ref<BinaryEmitter>, loc:ref<Long>, group:ref<Int>) -> ref<False> :
  emit-long(address-list, loc.value)
  return emit-long(address-list, group.value)

defn count-lines (entries:Tuple<VMSafepointInfo>) :
  var count = 0
  var previous = -1
  for info in entries do :
    val current = line(info)
    if current != previous :
      previous = current
      count = count + 1
  count

lostanza defn dispose-safepoints (vm:ref<VirtualMachine>) -> ref<False> :
  val vms:ptr<VMState> = vm.vmstate
  val safepoint-table = vms.safepoint-table as ptr<SafepointTable>
  if safepoint-table != null :
    val num-files = safepoint-table.num-files
    for (var i:long = 0, i < num-files, i = i + 1L) :
      dispose-safepoints(safepoint-table.files[i])
    vms.safepoint-table = null
  return false
lostanza defn dispose-safepoints (safepoints:ptr<FileSafepoints>) -> ref<False> :
  call-c clib/free(safepoints.filename)
  val num-entries = safepoints.num-entries
  for (var i:long = 0, i < num-entries, i = i + 1L) :
    call-c clib/free(safepoints.entries[i].address-list)
  return false

;============================================================
;==================== Local Var Table =======================
;============================================================

defstruct LocalTablePacker :
  var-names:StringPool with: (default => StringPool())
  named-vars:Vector<LocalVar> with: (default => Vector<LocalVar>())
  context-lengths:Vector<Int> with: (default => Vector<Int>())
  varmaps:Vector<VarMapEntry> with: (default => Vector<VarMapEntry>())
  index-maps:Vector<Tuple<Int>> with: (default => Vector<Tuple<Int>>())
  index-map-table:HashTable<Tuple<Int>,Int> with: (default => HashTable<Tuple<Int>,Int>())
defstruct LocalVar :
  stack-offset:Int
  name-offset:Int
defstruct VarMapEntry :
  pc:Long
  context-index:Int
  index-map-index:Int

defn add (packer:LocalTablePacker, cntx:Vector<NamedLocalVar>, maps:Vector<LocalVarMapEntry>) :
  if not empty?(maps) :
    val context-lengths = context-lengths(packer)
    val cntx-index = length(context-lengths)
    add(context-lengths, length(cntx))

    add-all(named-vars(packer), seq(LocalVar, cntx)) where :
      defn LocalVar (v:NamedLocalVar) :
        /LocalVar(stack-offset(v), /add(var-names(packer), name(v)))

    add-all(varmaps(packer), seq(VarMapEntry, maps)) where :
      defn VarMapEntry (v:LocalVarMapEntry) :
        /VarMapEntry(pc(v), cntx-index, index-map-index(indices(v))) where :
          defn index-map-index (vars:Tuple<Int>) -> Int :
            val index-maps = index-maps(packer)
            val index-map-table = index-map-table(packer)
            match(get?(index-map-table, vars)) :
              (i:Int) :
                i
              (f:False) :
                val i = length(index-maps)
                add(index-maps, vars)
                index-map-table[vars] = i
                i

defn pack (packer:LocalTablePacker, vm:VirtualMachine) -> False :
  ;See LSLocalVarTable and local-table-stitcher for the details.
  val LSLocalVarTable-size = 5 * 8
  val e = make-binary-emitter(LSLocalVarTable-size)
  emit(e, emit-varmaps(packer))
  emit(e, emit-contexts(packer))
  emit(e, emit-named-vars(packer))
  emit(e, emit-index-maps(packer))
  emit(e, emit-indices(packer))
  set-local-var-table(e, vm)
  false
lostanza defn set-local-var-table (e:ref<BinaryEmitter>, vm:ref<VirtualMachine>) -> ref<False> :
  vm.vmstate.local-var-table = e.start
  return false
defn emit-varmaps (packer:LocalTablePacker) -> BinaryEmitter :
  val varmaps = varmaps(packer)
  val VarMapEntry-size = 8 + 4 + 4
  val varmaps-size = 8 + VarMapEntry-size * length(varmaps)
  val e = make-binary-emitter(varmaps-size)
  for v in varmaps do :
    emit-long(e, pc(v))
    emit-int(e, context-index(v))
    emit-int(e, index-map-index(v))
  e
defn emit-contexts (packer:LocalTablePacker) -> BinaryEmitter :
  val context-lengths = context-lengths(packer)
  val length = length(context-lengths) + 1
  val contexts-size = 4 * (length + 1)
  val e = make-binary-emitter(contexts-size)
  emit-int(e, length)
  var base = 0
  for len in context-lengths do :
    emit-int(e, base)
    base = base + len
  emit-int(e, base)
  e
defn emit-named-vars (packer:LocalTablePacker) -> BinaryEmitter :
  val var-names = var-names(packer)
  val vars = named-vars(packer)
  val vars-size = 8 + 16 * length(vars) ;long length + sizeof(LSNamedVar)
  val var-names-size = pos(var-names)
  ;There is no pointer to string table in LSLocalVarTable. Let's append
  ;string table to named vars to avoid memory leak
  val e = make-binary-emitter(vars-size + var-names-size)
  emit-long(e, length(vars))
  for v in vars do :
    emit-long(e, stack-offset(v))
    emit-addr(e, name-offset(v) + vars-size)
  for x in map(var-names) do :
    copy(e, value(x) + vars-size, key(x))
  e
defn emit-index-maps (packer:LocalTablePacker) -> BinaryEmitter :
  val index-maps = index-maps(packer)
  val index-maps-length = length(index-maps)
  val index-maps-size = 4 + 4 * (index-maps-length + 1)
  val e = make-binary-emitter(index-maps-size)
  emit-int(e, index-maps-length)
  var base = 0
  for map in index-maps do :
    emit-int(e, base)
    base = base + length(map)
  emit-int(e, base)
  e
defn emit-indices (packer:LocalTablePacker) -> BinaryEmitter :
  val index-maps = index-maps(packer)
  val num-indices = sum(seq(length, index-maps))
  val indices-size = 4 + 4 * num-indices
  val e = make-binary-emitter(indices-size)
  emit-int(e, num-indices)
  for i in cat-all(index-maps) do :
    emit-int(e, i)
  e

lostanza defn dispose-local-var-table (vm:ref<VirtualMachine>) -> ref<False> :
  val vms:ptr<VMState> = vm.vmstate
  val local-var-table:ptr<LSLocalVarTable> = vms.local-var-table
  vms.local-var-table = null
  if local-var-table != null :
    call-c clib/free(local-var-table.varmaps)
    call-c clib/free(local-var-table.contexts)
    call-c clib/free(local-var-table.named-vars)
    call-c clib/free(local-var-table.index-maps)
    call-c clib/free(local-var-table.indices)
    call-c clib/free(local-var-table)
  return false

lostanza defn emit-long (e:ref<BinaryEmitter>, v:ref<Int>) -> ref<False> :
  return emit-long(e, v.value)
lostanza defn emit-addr (e:ref<BinaryEmitter>, offset:ref<Int>) -> ref<False> :
  return emit(e, e.start + offset.value)

defstruct StringPool :
  map:HashTable<String,Int> ;Maps string value to the offset from the pool start
  pos:Int with: (setter => set-pos)
defn StringPool () :
  StringPool(HashTable<String,Int>(), 0)
defn add (pool:StringPool, s:String) -> Int :
  val map = map(pool)
  match(get?(map, s)) :
    (pos:Int):
      pos
    (f:False):
      val pos = pos(pool)
      map[s] = pos
      set-pos(pool, pos + size(s))
      pos
defn size (s:String) :
  length(s) + 1

lostanza deftype BinaryEmitter :
  start:ptr<?>
  var p:ptr<?>
lostanza defn make-binary-emitter (size:long) -> ref<BinaryEmitter> :
  val p:ptr<?> = call-c clib/malloc(size)
  return new BinaryEmitter{p, p}
lostanza defn make-binary-emitter (size:ref<Long>) -> ref<BinaryEmitter> :
  return make-binary-emitter(size.value)
lostanza defn make-binary-emitter (size:ref<Int>) -> ref<BinaryEmitter> :
  return make-binary-emitter(to-long(size))
lostanza defn emit (p:ptr<int>, v:int) -> ptr<int> :
  [p] = v
  return addr(p[1])
lostanza defn emit (p:ptr<long>, v:long) -> ptr<long> :
  [p] = v
  return addr(p[1])
lostanza defn emit (dst:ptr<?>, src:ptr<?>, len:long) -> ptr<?> :
  return call-c clib/memcpy(dst, src, len) + len
lostanza defn emit (dst:ptr<?>, s:ref<String>) -> ptr<?> :
  return emit(dst, addr!(s.chars), s.length + 1)
lostanza defn emit-int (emitter:ref<BinaryEmitter>, value:int) -> ref<False> :
  emitter.p = emit(emitter.p as ptr<int>, value)
  return false
lostanza defn emit-long (emitter:ref<BinaryEmitter>, value:long) -> ref<False> :
  emitter.p = emit(emitter.p as ptr<long>, value)
  return false
lostanza defn emit-int (emitter:ref<BinaryEmitter>, x:ref<Int>) -> ref<False> :
  return emit-int(emitter, x.value)
lostanza defn emit-long (emitter:ref<BinaryEmitter>, x:ref<Long>) -> ref<False> :
  return emit-long(emitter, x.value)
lostanza defn emit (emitter:ref<BinaryEmitter>, value:ptr<?>) -> ref<False> :
  return emit-long(emitter, value as long)
lostanza defn emit (emitter:ref<BinaryEmitter>, value:ref<BinaryEmitter>) -> ref<False> :
  return emit(emitter, value.start)
lostanza defn copy (emitter:ref<BinaryEmitter>, pos:ref<Int>, s:ref<String>) -> ref<False> :
  call-c clib/memcpy(emitter.p + pos.value, addr!(s.chars), s.length + 1)
  return false

;============================================================
;========= Launching the Initialization Function ============
;============================================================
;This function is the standard way of launching some code to execute
;in the JIT. It calls `core/execute-toplevel-command()` with the given
;function passed as a closure. All fatals/exceptions are intercepted
;by execute-toplevel-command, and thus it is guaranteed to return
;normally. launch-init() returns the boolean that is returned by
;execute-toplevel-command().
;- fid: The identifier of the VMFunction to execute.

lostanza defn launch-init (vm:ref<VirtualMachine>, fid:ref<Int>) -> ref<True|False> :
  ;Create the closure representing the initialization function
  val closure-size = 8 + 8
  ensure-heap-space(vm, closure-size)
  val closure:ptr<Function> = allocate-initial(heap(vm), FN-TYPE.value, closure-size)
  closure.num-slots = 0L
  closure.code = fid.value
  ;Call closure using the launcher function
  val vms = vm.vmstate
  vms.registers[0] = false-marker()
  vms.registers[1] = 1L
  vms.registers[2] = tag-as-ref(closure)
  run-bytecode(vm, EXECUTE-TOPLEVEL-COMMAND-FN)
  ;Return whether successful or not
  val ret = vms.registers[0]
  if ret == false-marker() : return false
  else if ret == true-marker() : return true
  else : return fatal("Invalid return value from execute-toplevel-command.")

;============================================================
;================= Releasing Resources ======================
;============================================================

public defn shutdown (vm:VirtualMachine) :
  free-code-table(vm)
  dispose-debug-table(vm)
  dispose-local-var-table(vm)
  dispose-safepoints(vm)
lostanza defn free-code-table (vm:ref<VirtualMachine>) -> ref<False> :
  free(vm.vmtable.code-table)
  return false

;============================================================
;==================== Utilities =============================
;============================================================

var delay : (() -> ?) -> False =
  fn (f) : fatal("Not within delay-actions block.")
defn delay-actions<?T> (f:() -> ?T) :
  val delays = Vector<(() -> ?)>()
  defn delay-action (action:() -> ?)  : add(delays, action)
  val result = let-var delay = delay-action : f()
  for d in delays do : d()
  clear(delays)
  result
